# Экзаменационные вопросы по предмету "Программирование на языке Джава"

> Если вы хотите помочь с заполнением вопросов или хотите исправить ошибку, то создайте issue или pull request. Спасибо!

## Тема 1. Особенности платформы Java. Синтаксис языка Java

### 1. К какому типу языков относится язык Джава

**Java** — строго типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process; язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.

Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины. Дата официального выпуска — 23 мая 1995 года. Занимает высокие места в рейтингах популярности языков программирования (2-е место в рейтингах IEEE Spectrum (2020) и TIOBE (2021)).

### 2. Особенности языка Джава

Некоторые из ключевых особенностей языка программирования Java:

- **Объектно-ориентированность**: Java является объектно-ориентированным языком, что означает, что он позволяет разработчикам определять объекты и манипулировать ими в своем коде.

- **Независимость от платформы**: Java-программы компилируются в байт-код, который можно запускать на любом устройстве, на котором установлена виртуальная машина Java (JVM). Это означает, что программы Java являются переносимыми, то есть их можно запускать на любом устройстве, поддерживающем Java, независимо от используемого оборудования и операционной системы.

- **Многопоточность**: Java позволяет разработчикам создавать многопоточные программы, что означает, что программа может выполнять несколько задач одновременно. Это полезно для разработки программ, которые должны выполнять несколько задач одновременно, например веб-серверов, которым необходимо обрабатывать несколько запросов одновременно.

- **Надежность**: Java обладает рядом функций, которые делают его надежным языком, включая механизм сборки мусора, который автоматически освобождает память, используемую объектами, которые больше не нужны, и строгую систему типов, помогающую предотвратить распространенные ошибки программирования.

- **Безопасность**: Java имеет встроенную поддержку функций безопасности, таких как возможность цифровой подписи и проверки кода, а также возможность шифрования и расшифровки данных.

- **Высокая производительность**: Java-программы можно оптимизировать для быстрой работы, и существует ряд инструментов и методов, помогающих разработчикам писать высокопроизводительный Java-код.

- **Широкое использование**: Java является одним из самых популярных языков программирования в мире и используется для разработки широкого спектра приложений, включая веб-приложения, мобильные приложения, настольные приложения и серверные приложения.

### 3. Класс Scanner и его использование для чтения стандартного потока ввода

Класс `Scanner` — это класс Java, который используется для чтения входных данных из различных источников, таких как файлы, сетевые сокеты и стандартный поток ввода (stdin). Он является частью пакета `java.util` и может использоваться для чтения входных данных различных типов, таких как целые числа, двойные числа, строки и логические значения.

Чтобы использовать класс `Scanner` для чтения ввода из стандартного потока ввода, вы можете создать новый объект `Scanner` и передать стандартный поток ввода `(System.in)` в качестве аргумента конструктору. Например:

```Java
Scanner scanner = new Scanner(System.in);
```

После того, как вы создали объект `Scanner`, вы можно использовать его различные методы для чтения ввода из стандартного потока ввода. Например, чтобы прочитать целое число из стандартного потока ввода, вы можно использовать метод `nextInt()`:

```Java
int i = scanner.nextInt();
```

Чтобы прочитать двойное число, вы можно использовать метод `nextDouble()`:

```Java
double d = scanner.nextDouble();
```

Чтобы прочитать строку, вы можно использовать метод nextLine():

```Java
String s = scanner.nextLine();
```

Также можно передать объект `File`, URL-адрес или строку, содержащую входные данные, конструктору сканера для чтения входных данных из этих источников. Например, чтобы прочитать ввод из файла, можно сделать что-то вроде этого:

```Java
File file = new File("input.txt");
Scanner scanner = new Scanner(file);
```

Или, чтобы прочитать ввод с URL-адреса, можно сделать это:

```Java
URL url = new URL("http://www.example.com");
Scanner scanner = new Scanner(url.openStream());
```

Также можно использовать метод `hasNext()`, чтобы проверить, доступны ли дополнительные данные для чтения, и метод `close()`, чтобы закрыть `Scanner` и освободить все используемые им ресурсы.

Вот пример того, как можно использовать класс `Scanner` для чтения ряда целых чисел из стандартного потока ввода и вывода их суммы:

```Java
int sum = 0;
while (scanner.hasNextInt()) {
    int n = scanner.nextInt();
    sum += n;
}
System.out.println("Sum: " + sum);
scanner.close();
```

### 4. Класс Scanner, конструктор класса Scanner для чтения стандартного потока ввода

Дубликат вопроса 3.

### 5. Методы класса Scanner nextLine(), nextInt(), hasNextInt(), hasNextLine() и их использование для чтения ввода пользователя с клавиатуры

Можно использовать его различные методы для чтения ввода от пользователя. Вот некоторые распространенные методы класса `Scanner` и то, как их можно использовать для чтения ввода от пользователя:

- `nextLine()`: считывает строку ввода (то есть строку, которая заканчивается символом новой строки) от пользователя.
  
- `nextInt()`: считывает целое число от пользователя.
  
- `hasNextInt()`: возвращает `true`, если есть целое число, доступное для чтения, и `false` в противном случае.
  
- `hasNextLine()`: возвращает `true`, если есть строка ввода, доступная для чтения, и `false` в противном случае.

### 6. Примитивные типы данных, объявление и присваивание переменных

В Java примитивный тип данных — это базовый тип данных, встроенный в язык и представляющий одно значение. В Java существует восемь примитивных типов данных:

- `boolean`: логическое значение. Может быть либо true, либо false.
- `char`: символьное значение. это один символ, например «a» или «1».
- `byte`: значение с плавающей запятой, представляющее собой 8-битное целое число со знаком (от -128 до 127).
- `short`: целочисленное значение, представляющее собой 16-разрядное целое число со знаком (от -32 768 до 32 767).
- `int`: целочисленное значение, представляющее собой 32-разрядное целое число со знаком (от -2 147 483 648 до 2 147 483 647).
- `long`: целочисленное значение, представляющее собой 64-битное целое число со знаком (от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807).
- `float`: значение с плавающей запятой, представляющее собой 32-разрядное число с плавающей запятой одинарной точности.
- `double`: значение с плавающей запятой, представляющее собой 64-разрядное число с плавающей запятой двойной точности.

Чтобы объявить переменную в Java, вам нужно указать тип данных переменной и имя для переменной. Например:

```Java
int x;
double y;
```

Это объявляет две переменные, x и y, типа `int` и `double` соответственно.

Чтобы присвоить значение переменной, можно использовать оператор присваивания (=). Например:

```Java
int x = 5;
double y = 3.14;
```

Это присваивает значение 5 переменной x и значение 3,14 переменной y.

Важно отметить, что нельзя изменить тип данных переменной после ее объявления. Например, если вы объявите переменную типа `int`, вы не сможете впоследствии присвоить ей `double` значение.

### 7. Условные операторы, полное и неполное ветвление в Джава, синтаксис

В Java можно использовать условные операторы для выполнения ветвления, что означает выполнение различных блоков кода в зависимости от значения определенных условий.

В Java есть три основных типа условных операторов:

- Оператор `if`. Оператор `if` позволяет выполнить блок кода, если выполняется определенное условие. Например:

```Java
if (x > 0) {
    System.out.println("x is positive");
}
```

- Оператор `if-else`. Оператор `if-else` позволяет выполнять один блок кода, если определенное условие истинно, и другой блок кода, если условие ложно. Например:

```Java
if (x > 0) {
    System.out.println("x is positive");
} else {
    System.out.println("x is not positive");
}
```

- Оператор `switch`: оператор `switch` позволяет выполнять другой блок кода на основе значения переменной или выражения. Например:

```Java
switch (x) {
    case 1:
        System.out.println("x is 1");
        break;
    case 2:
        System.out.println("x is 2");
        break;
    default:
        System.out.println("x is something else");
        break;
}
```

Также можно использовать условный оператор (также известный как тернарный оператор) для выполнения простого ветвления в одной строке кода. Синтаксис условного оператора следующий:

`условие? значение_если_истина : значение_если_ложь`

Например:

```Java
int y = (x > 0) ? 1 : -1;
```

### 8. Оператор множественного выбора в Джава, синтаксис

Можно использовать оператор `switch` для выполнения нескольких ветвлений на основе значения переменной или выражения. Синтаксис оператора `switch` следующий:

```Java
switch (expression) {
    case value1:
        // code to execute if expression equals value1
        break;
    case value2:
        // code to execute if expression equals value2
        break;
    // ...
    default:
        // code to execute if expression does not match any of the case values
        break;
}
```

Необходмо обратить внимание, что каждый `case` в операторе `switch` должен завершаться оператором `break`, что приводит к выходу потока управления из оператора `switch`. Если опустить оператор `break`, поток управления продолжится до следующего случая, что может привести к непредвиденным последствиям.

### 9. Класс System. Работа со стандартами потоками вывода

Класс `System` — это встроенный класс Java, предоставляющий доступ к различным функциям и переменным системного уровня. Одной из функций, предоставляемых классом `System`, является возможность работы со стандартным потоком вывода, представляющим собой поток, который используется для вывода данных на консоль или в окно терминала.

Для вывода данных в стандартный поток вывода в Java можно использовать статический метод `println()` объекта `System.out`. Этот метод принимает один аргумент, то есть данные, которые вы хотите вывести, и выводит данные на консоль, за которыми следует символ новой строки.

Например, чтобы вывести строку «Hello, world!» в консоль можно использовать следующий код:

```Java
System.out.println("Hello, world!");
```

Также можно использовать статический метод `print()` объекта `System.out` для вывода данных в стандартный поток вывода без символа новой строки. Например:

```Java
System.out.print("Hello, ");
System.out.print("world!");
```

В дополнение к методам `println()` и `print()` объект System.out предоставляет несколько других методов для вывода данных в стандартный поток вывода, например, `printf()` для форматированного вывода и `write()` для записи необработанных байтов.

Метод `printf()` — это метод класса `PrintStream` (который является суперклассом объекта `System.out`), который используется для вывода форматированной строки в стандартный поток вывода. Он принимает строку формата и список аргументов и заменяет заполнители в строке формата соответствующими аргументами.

Вот пример того, как можно использовать метод `printf()` для вывода форматированной строки на консоль:

Метод `write()`, с другой стороны, является методом класса `OutputStream` (который является суперклассом класса `PrintStream`), который используется для записи для записи одиночных байтов или массива байтов в стандартный поток вывода. Он принимает массив байтов в качестве аргумента и записывает байты в поток.

```Java
byte[] data = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21};
System.out.write(data);
```

Вот пример того, как вы можете использовать метод `write()` для вывода массива байтов на консоль:

```Java
int x = 10;
double y = 3.14;
System.out.printf("x is %d and y is %f\n", x, y);
```

Этот код выведет строку `«Hello, world!»` к консоли. Массив байтов содержит коды ASCII для символов в строке, а метод `write()` записывает байты в стандартный поток вывода.

Метод `write()` не добавляет автоматически символ новой строки, поэтому вам нужно использовать отдельный вызов `println()`, если вы хотите включить новую строку в свой вывод.

### 10. Перегруженные методы out.println() класса System и их использование для вывода в консоль

Метод `println()` объекта `System.out` является перегруженным методом, что означает, что он имеет несколько версий, которые принимают различные типы аргументов. Различные версии метода `println()` позволяют вам выводить на консоль различные типы данных удобным и простым способом.

Вот список различных версий метода `println()` вместе с типами аргументов, которые они принимают, и соответствующим выводом, который они производят:

- `println(boolean x)`: принимает логическое значение и выводит либо «true», либо «false».
- `println(char x)`: принимает значение char и выводит символ,.
- `println(int x)`: принимает значение int и выводит целое число.
- `println(long x)`: принимает long значение и выводит целое число.
- `println(float x)`: принимает значение с плавающей запятой и выводит число с плавающей запятой.
- `println(double x)`: принимает значение с плавающей запятой и выводит число с плавающей запятой.
- `println(char[] x)`: принимает массив значений char и выводит символы в массиве. В качестве типа массива можно использовать и другие типы.
- `println(String x)`: принимает значение String и выводит строку.
- `println(Object x)`: принимает любой объект и выводит результат вызова метода объекта `toString()`.

### 11. Константы в Джава: объявление константы

В Java вы можете объявить константу, используя ключевое слово `final`. Константа — это значение, которое нельзя изменить после его инициализации.

Чтобы объявить константу в Java, вы можете использовать следующий синтаксис:

```Java
final TYPE_NAME = VALUE;
```

Также можно использовать ключевые слова `static` и `final` вместе, чтобы объявить константу, которая является переменной класса (т. е. переменной, которая является общей для всех экземпляров класса). Например:

```Java
public class MyClass {
    static final double PI = 3.14159;
    // ...
}
```

Константы должны быть инициализированы значением при их объявлении. Нельзя объявить константу и оставить ее неинициализированной.

### 12. В результате выполнения этой строчки

???

### 13. Объявление и использование бестиповых переменных в Джава

В Java нет концепции нетипизированных переменных. Все переменные в Java должны иметь определенный тип, который определяет значения, которые может содержать переменная, и операции, которые можно с ней выполнять.

Однако в Java есть тип `Object`, который можно использовать для хранения ссылки на любой объект. Тип `Object` является корнем иерархии классов в Java, и все классы являются подклассами `Object`.

Пример объявления:

```Java
Object obj;
```

Можно присвоить любой объект этой переменной, например:

```Java
obj = "Hello, world!"; // assign a String object to obj
obj = 123; // assign an Integer object to obj
```

Необходимо обратить внимание, что когда присваивается примитивное значение (например, `int` или `double`) переменной `Object`, это значение автоматически помещается в объект соответствующего класса-оболочки (например, `Integer` или `Double`). Это известно как Автобоксинг.

Чтобы получить доступ к значению, хранящемуся в переменной типа `Object`, необходимо привести его к соответствующему типу, а затем использовать соответствующие методы для извлечения значения. Например:

```Java
String str = (String) obj; // cast obj to a String and assign it to str
int x = ((Integer) obj).intValue(); // cast obj to an Integer and extract the int value
```

Важно быть осторожным при работе с нетипизированными переменными, так как они могут привести к ошибкам во время выполнения, если попытаться использовать их способом, несовместимым с их фактическим типом.

Как правило, рекомендуется использовать типизированные переменные, когда это возможно, так как они могут помочь предотвратить ошибки и сделать ваш код более понятным. Однако бывают ситуации, когда нетипизированные переменные могут быть полезны, например, когда вам нужно записать значение типа, неизвестного во время компиляции.

### 14. Объявление переменных и инициализация типа класс

Чтобы инициализировать переменную типа класса (т. е. переменную, которая содержит ссылку на объект), можно использовать оператор `new` для создания экземпляра класса и присвоения ссылки переменной.

Например:

```Java
String str = new String("Hello, world!");
```

Также можно использовать оператор `new` для создания экземпляра класса с конструктором, принимающим аргументы. Например:

```Java
public class MyClass {
    private int x;
    private int y;
    public MyClass(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

Чтобы создать экземпляр MyClass и инициализировать его значениями 10 и 20, используем следующий код:

```Java
MyClass obj = new MyClass(10, 20);
```

Важно отметить, что переменные типа класса являются ссылками на объекты, а не на объектами. Когда вы присваиваете переменную типа класса другой переменной, вы копируете только ссылку, а не сам объект.

Важно отметить, что необходимо инициализировать переменную типа класса, прежде чем использовать.

### 15. Арифметические операции, операции инкремента и декремента в Джава

В Java можно выполнять арифметические операции, используя стандартные арифметические операторы: `+` для сложения, `-` для вычитания, `*` для умножения, `/` для деления и `%` (остаток от деления).

Вы также можете использовать операторы `++` и `--` для инкремента и декремента. Например:

```Java
int x = 10;
x++; // x will be 11
x--; // x will be 10 again
```

Операторы `++` и `--` могут использоваться как префиксные операторы (например, `++x`) или постфиксные операторы (например, `x++`). При использовании в качестве префиксного оператора инкремент или декремент применяется до того, как значение переменной будет использовано в выражении. При использовании в качестве постфиксного оператора инкремент или декремент применяется после того, как значение переменной используется в выражении.

```Java
int x = 10;
int y = ++x; // y will be 11, x will be 11
int z = x++; // z will be 11, x will be 12
```

Важно отметить, что операторы ++ и -- имеют более высокий приоритет, чем арифметические операторы. Например:

```Java
int x = 10;
int y = 20;
int z = x++ * y; // z will be 200, x will be 11 
```

Вы можете использовать круглые скобки, чтобы указать порядок операций, если вам нужно изменить приоритет операций.

### 16. В результате выполнения фрагмента программы

???

### 17. Арифметические операции, приоритет выполнения операций

Список приоритетов арифметических операторов в Java, от высшего к низшему:

- ++, -- (префикс инкремента и декремента)
- ! (логическое НЕ)
- *, / % (умножение, деление и остаток от деления)
- +, - (сложение и вычитание)
- <=, <, > и >= (операторы сравнения)
- ==, != (операторы равенства)
- && (логическое И)
- || (логическое ИЛИ)

### 18. Типы данных в языке Джава, классификация, примеры

В Java типы данных делят на две большие группы: примитивные и ссылочные. В состав примитивных типов (или просто примитивов) входят четыре подвида и восемь типов данных:

- целые числа (`byte`, `short`, `int`, `long`);

- числа с плавающей точкой (`float`, `double`);

- логический (`boolean`);

- символьный (`char`).

Ссылочные типы данных ещё называют ссылками. К ним относятся все классы, интерфейсы, массивы, а также тип данных `String`.

Хотя у примитивов и ссылок много общего, между ними есть существенные различия. И главное различие — в том, что именно в них хранится.

| Примитивные типы                                                                  | Ссылочные типы                                                                                                        |
| --------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| Хранят значение                                                                   | Хранят адрес объекта в памяти, на который ссылаются (отсюда и название).                                              |
| Создаются присваиванием значения                                                  | Создаются через конструкторы классов (присваивание только создаёт вторую ссылку на существующий объект)               |
| Имеют строго заданный диапазон допустимых значений                                | По умолчанию их значение — null                                                                                       |
| В аргументы методов попадают копии значения переменной (это передача по значению) | В методы передаётся значение ссылки — операция выполняется над оригинальным объектом, на который ссылается переменная |

### 19. Массивы в Джава, объявление и инициализация массивов, длина массива, получение доступа к элементу массива

В Java массив представляет собой набор фиксированного размера элементов одного и того же типа данных. Вы можете объявить массив, указав тип данных элементов и имя массива, за которыми следуют квадратные скобки `[]`. Например:

```Java
int[] numbers;
```

Инициалия массива означает создание массива определенного размера и заполнение его значениями по умолчанию (`0` для числовых типов, `false` для логических и `null` для ссылочных типов). Можно инициализировать массив с помощью оператора `new` и указать размер массива в квадратных скобках `[]`. Например:

```Java
int[] numbers = new int[10];
```

Также можно инициализировать массив определенными значениями, используя инициализатор массива. Инициализатор массива представляет собой список значений, заключенных в фигурные скобки `{}`.

```Java
int[] numbers = {1, 2, 3};
```

Важно отметить, что можно получать доступ только к элементам массива, которые находятся в пределах границ массива. Если вы попытаетесь получить доступ к элементу с отрицательным индексом или большим или равным размеру массива, вы вызовете исключение `ArrayIndexOutOfBoundsException`.

Вы можете использовать длину массива, используя `length`.

Размер массива фиксирован и не может быть изменен после создания массива. Если необходимо хранить переменное количество элементов, можно использовать, например, `arrayList` или `LinkedList`.

### 20. Массивы в Джава, как объектные типы данных, контроль доступа за выход за границы массива

В Java массивы — это объектные типы данных, что означает, что массив является экземпляром класса `Array`. Это означает, что массивы обладают некоторыми характеристиками объектов, такими как способность иметь поля (переменные) и методы (функции).

Одним из полей класса Array является поле `length`, которое содержит размер массива. Оно является константным полем, что означает, что оно не может быть изменено после инициализации массива.

Важно отметить, что можно получать доступ только к элементам массива, которые находятся в пределах границ массива. Если вы попытаетесь получить доступ к элементу с отрицательным индексом или большим или равным размеру массива, вы вызовете исключение `ArrayIndexOutOfBoundsException`.

Чтобы предотвратить это исключение, можно использовать поле `length`, чтобы проверить, находится ли индекс в пределах границ массива перед доступом к элементу. Например:

```Java
int[] numbers = {1, 2, 3};
int index = 5;
if (index >= 0 && index < numbers.length) {
    int element = numbers[index];
    System.out.println(element);
} else {
    System.out.println("Index out of bounds");
}
```

### 21. Операции над массивами, просмотр элементов массива, поиск по образцу, сортировка массива, сумма элементов массива

Чтобы просмотреть элементы массива, вы можете использовать цикл для перебора элементов массива. Например:

```Java
int[] numbers = {1, 2, 3, 4, 5};
for (int i = 0; i < numbers.length; i++) {
    int element = numbers[i];
    System.out.println(element);
}
```

Для поиска определенного элемента в массиве вы можете использовать цикл и условный оператор. Например:

```Java
int[] numbers = {1, 2, 3, 4, 5};
int target = 3;
for (int i = 0; i < numbers.length; i++) {
    if (numbers[i] == target) {
        System.out.println("Found at index " + i);
        break;
    }
}
```

Для сортировки массива можно использовать один из алгоритмов сортировки, предоставляемых стандартной библиотекой Java, например Arrays.sort(). Например:

```Java
int[] numbers = {4, 3, 2, 1, 5};
Arrays.sort(numbers);
```

Чтобы вычислить сумму элементов массива, вы можете использовать цикл для перебора элементов массива и добавления их к промежуточной сумме. Например:

```Java
int[] numbers = {1, 2, 3, 4, 5};
int sum = 0;
for (int i = 0; i < numbers.length; i++) {
    sum += numbers[i];
}
System.out.println("Sum: " + sum);
```

### 22. В результате выполнения фрагмента программы

???

### 23. Операция конкатенации строк в Джава, ее обозначение и использование и ее использование

В Java оператор `+` используется для конкатенации (объединения) строк. Например:

```Java
String s1 = "Hello";
String s2 = "World";
String s3 = s1 + " " + s2; // s3 = "Hello World"
```

Также можно использовать оператор `+` для объединения строки с нестроковым значением. В этом случае нестроковое значение будет преобразовано в строку с помощью метода `toString()`.

```Java
int i = 123;
String s = "The value is " + i; // s = "The value is 123"
```

Важно отметить, что конкатенация строк является относительно дорогостоящей операцией, поскольку она включает в себя создание нового строкового объекта и копирование в него содержимого старых строк. Если вам нужно объединить большое количество строк, как правило, более эффективно использовать `StringBuilder` или `StringBuffer`.

Например, чтобы объединить большое количество строк с помощью `StringBuilder`, вы можете использовать метод `append()`:

```Java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append("x");
}
String s = sb.toString();
```

`StringBuilder` и `StringBuffer` похожи на `String`, но они изменяемы, что означает, что вы можете изменять их содержимое, не создавая новый объект. Это делает их более эффективными для объединения строк, поскольку они позволяют избежать расходов на создание новых объектов для каждого объединения.

### 24. Циклы в Джава, цикл с предусловием, цикл с постусловием, пример записи и использование. Условие окончания цикла

Цикл `while` — это цикл с предусловием, то есть условие цикла проверяется до выполнения тела цикла. Цикл `while` имеет следующий синтаксис:

```Java
while (condition) {
// loop body
}
```

Цикл `do while` похож на цикл `while`, но условие проверяется после выполнения тела цикла. Цикл `do while` имеет следующий синтаксис:

```Java
do {
    // loop body
} while (condition);
```

### 25. Циклы в Джава, итерационный цикл for(), синтаксис, счетчик цикла, условие окончания цикла, модификация счетчика, пример использования

Цикл `for` — это цикл с счетчиком. Цикл `for` имеет следующий синтаксис:

```Java
for (initialization; condition; iteration) {
    // loop body
}
```

Счетчик цикла инициализируетася перед выполнением цикла.

Условие окончания цикла проверяеттся перед каждой итерацией цикла. Если условие истинно, цикл продолжается; в противном случае цикл завершается.

Модификатор счетчика выполняется после каждой итерации цикла. Обычно он используется для обновления переменной цикла.

Пример использования:

```Java
for (int i = 1; i <= 10; i++) {
    System.out.println(i);
}
```

### 26. Способы объявления массивов в Джава, использование операции new для выделения памяти для элементов массива. Объявление с инициализацией, объявление массива определенного размера без инициализации

Дубликат 19 вопроса

## Тема 2. Реализация ООП в Java

### 27. Объявление класса на Джава, пример объявления

В Java класс — это шаблон для создания объектов. Класс определяет данные и поведение (методы) типа объекта.

Чтобы объявить класс в Java, используется ключевое слово `class`, за которым следует имя класса. Тело класса заключено в фигурные скобки `{}`.

```Java
class MyClass {
    // class body
}
```

### 28. Использования this для доступа к компонентам класса

Иногда требуется, чтобы метод ссылался на вызвавший его объект. Ключевое слово `this` в Java используется в теле любого метода для ссылки на текущий объект.

```Java
class Point {
    private double x;
    private double y;
    void setLocation(double x, double y) {
        this.x = x; // refers to the "x" field of the current object
        this.y = y; // refers to the "y" field of the current object
    }
}
```

### 29. Создание или инстанцирование объектов типа класс

В Java вы можете создавать экземпляры (объекты) класса с помощью оператора `new`.

Например, рассмотрим следующий класс:

```Java
class Point {
    double x;
    double y;
}
```

Чтобы создать объект типа Point, можно использовать следующий код:

```Java
Point p = new Point();
```

Можно инициализировать поля следующим образом:

```Java
p.x = 3;
p.y = 4;
```

Кроме того, можно инициализировать поля, заключив значения в фигурные скобки `{}`.

```Java
Point p = new Point { x = 3, y = 4 };
```

Когда создается объект с помощью оператора `new`, вызывается конструктор для данного объекта.

### 30. Что такое класс в Java?

Класс в Java - это шаблон для создания объекта, а объект - это экземпляр класса. Класс определяет структуру и поведение, которые будут совместно использоваться набором объектов. Класс содержит переменные и методы, которые называются элементами класса, членами класса.

### 31. Модификатор доступа или видимости в Джава, виды и использование

Все члены класса в языке Java - поля и методы - имеют модификаторы доступа. Модификаторы доступа позволяют задать допустимую область видимости для членов класса, то есть контекст, в котором можно употреблять данную переменную или метод.

В Java используются следующие модификаторы доступа:

- `public`: публичный, общедоступный класс или член класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов.
- `private`: закрытый класс или член класса, противоположность модификатору public. Закрытый класс или член класса доступен только из кода в том же классе.
- `protected`: такой класс или член класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
- Модификатор по умолчанию. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

### 32. Чем отличаются static-метод класса от обычного метода класса

В Java статический метод — это метод, связанный с классом, а не с экземпляром (объектом) класса. Статический метод можно вызывать для самого класса, а не для объекта класса.

Обычный (нестатический) метод — это метод, связанный с экземпляром (объектом) класса. Обычный метод может быть вызван для объекта класса и может получить доступ к полям и методам объекта.

Методы с модификатором `static` не могут использовать ключевое слово `this`

### 33. Для чего используется оператор new?

Дубликат 29 вопроса

### 34. Можно ли вызвать static-метод внутри обычного метода?

Да, статический метод можно вызвать из обычного (нестатического) метода в Java.

Чтобы вызвать статический метод из обычного метода, можно исполльзовать имя класса, за которым следует точка и имя метода. Например:

```Java

double distanceFromOrigin() {
    return Math.sqrt(x * x + y * y);
}
```

### 35. Как вызвать обычный метод класса внутри static-метода?

Чтобы вызвать обычный метод из статического метода, нужно создать объект класса и вызвать обычный метод для этого объекта. Например:

```Java
static double distanceFromOrigin(Point p) {
    double dx = p.x;
    double dy = p.y;
    return Math.sqrt(dx * dx + dy * dy);
}
```

### 36. Для чего используется в Джава ключевое слово this?

Ключевое слово `this` в Java используется для ссылки на текущий объект. Ключевое слово `this` можно использовать внутри метода класса для ссылки на текущий объект. Например:

```Java
public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}
```

### 37. Объявление и использование методов, объявленных с модификатором public static

В Java метод, объявленный с модификатором `public static`, является методом, доступным из любой точки программы и связанным с классом, а не с объектом класса. Методы могут быть вызваны без создания объекта класса. Например:

```Java
public class Point {
    public static double square(double x) {
        return x * x;
    }
}

public class Main {
    public static void main(String[] args) {
        double x = 3.0;
        double y = Point.square(x);
        System.out.println(y);
    }
}
```

### 38. Синтаксис объявления методов, тип возвращаемого значения, формальные параметры и аргументы

В Java методы - это блоки кода, которые выполняют определенные действия. Методы могут принимать аргументы и возвращать значение. Синтаксис объявления метода в Java следующий:

```Java
[модификаторы] тип_возвращаемого_значения имя_метода(формальные_параметры) {
    // тело метода
}
```

Здесь тип возвращаемого значения - это тип данных, который возвращает метод. Формальные параметры - это переменные, которые используются внутри метода. Аргументы - это значения, которые передаются в метод при его вызове.

### 39. Методы с пустым списком параметров

В Java методы могут быть объявлены с пустым списком параметров. В этом случае метод может быть вызван без передачи аргументов. Например:

Для объявления метода с пустым списком параметров используется следующий синтаксис:

```Java
[модификаторы] тип_возвращаемого_значения имя_метода() {
    // тело метода
}
```

Если перед вызовом метода передавать аргументы в метод, то компилятор выдаст ошибку.

### 40. Стандартные методы класса сеттеры и геттеры, синтаксис и их назначение?

Сеттеры и геттеры - это методы класса, которые используются для установки и получения значений полей класса.

Методы обычно используются для обеспечения контроля доступа к полям объекта, поскольку они позволяют указать, как можно получить доступ к полям и изменить их. Они также используются для проверки устанавливаемых или извлекаемых значений и для выполнения любых необходимых действий при изменении значений.

Сеттеры и геттеры обычно имеют следующий синтаксис:

```Java
[модификаторы] тип_возвращаемого_значения getИмя_поля() {
    // тело метода
}

[модификаторы] void setИмя_поля(тип_параметра имя_параметра) {
    // тело метода
}
```

### 41. Может ли быть поле данных класса объявлено как с модификатором static и final одновременно и что это означает?

Да, это возможно. Статическое поле данных — это поле данных, которое принадлежит классу, а не объекту. Статическое поле данных может быть объявлено как final, что означает, что его значение не может быть изменено после инициализации.

### 42. Методы класса конструкторы, синтаксис и назначение

Конструкторы — это методы класса, которые используются для инициализации объектов класса. Конструкторы имеют следующий синтаксис:

```Java
[модификаторы] Имя_класса([параметры]) {
    // тело метода
}
```

Конструкторы могут быть перегружены, то есть иметь одинаковое имя, но разные параметры.

Конструкторы могут быть объявлены как `public`, `private` или `protected`.

Конструктор необязательно должен быть объявлен в классе. Если конструктор не объявлен в классе, то компилятор автоматически создает конструктор по умолчанию, который не имеет параметров и не выполняет никаких действий.

### 43. Может ли класс иметь в своем составе несколько конструкторов?

Да, класс может иметь в своем составе несколько конструкторов. Конструкторы могут быть перегружены, то есть иметь одинаковое имя, но разные параметры.

Пример:

```Java
class MyClass {
    int x;
    MyClass() {
        x = 10;
    }
    MyClass(int i) {
        x = i;
    }
}
```

### 44. Может ли конструктор класса возвращать значение?

Нет, конструктор класса не может возвращать значение. Конструктор класса используется для инициализации объектов класса. Конструктор класса не может возвращать значение, так как возвращаемое значение должно быть типа `void`.

## Тема 3. Реализация наследования в программах на Джаве

### 45. Наследование в Джава. Вид наследования и синтаксис Ключевое слово extends

Наследование в Джава - это механизм, который позволяет создавать новые классы на основе уже существующих. Новый класс называется подклассом (дочерним классом, производным классом), а существующий класс называется суперклассом (родительским классом, базовым классом).

Ключевое слово `extends` используется для наследования класса. Оно указывает, что класс, который объявляется после ключевого слова `extends`, является суперклассом для класса, который объявляется до ключевого слова `extends`.

Существует несколько видов наследования:

- Одиночное наследование (single inheritance). При этом класс может наследовать только один суперкласс. Синтаксис:

```Java
class SubClass extends SuperClass {
    // тело класса
}
```

- Множественное наследование. В Java множественное наследование не поддерживается. Однако стоит упомянуть, что класс может реализовывать несколько интерфейсов.

- Иерархическое наследование. При этом класс может наследовать суперкласс, который в свою очередь может наследовать другой суперкласс и т.д. Синтаксис:

```Java
class SubClass extends SuperClass {
    // тело класса
}
class SubSubClass extends SubClass {
    // тело класса
}
```

### 46. Что означает перегрузка метода в Java (overload)?

Перегрузка метода - это возможность создавать несколько методов с одинаковым именем, но с разными параметрами. При этом каждый метод должен иметь уникальный набор параметров. При вызове метода компилятор выбирает метод, который соответствует переданным параметрам.

Пример:

```Java
public class calc {
    public int add(int a, int b) {
        return a + b;
    }
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    public double add(double a, double b) {
        return a + b;
    }
}
```

Перегрузка методов — полезная возможность,  поскольку он позволяет повторно использовать одно и то же имя метода для разных целей.

Однако стоит упомянуть, что перегрузка методов не всегда является хорошей практикой. Например, если методы имеют одинаковые названия, но разные параметры, то это может привести к путанице. Поэтому стоит использовать перегрузку методов только в тех случаях, когда это действительно необходимо.

Также перегрузка не является полной заменой переопределения методов. Перегрузка методов используется для создания различных вариантов одного и того же метода, а переопределение методов используется для изменения поведения метода в подклассе.

### 47. Что означает переопределение метода в Java (override)?

Переопределение метода - это возможность создавать методы с одинаковым именем и параметрами, но с разным телом. При этом методы должны быть объявлены в одном классе, но в разных подклассах.

Пример:

```Java
public class calc {
    public int add(int a, int b) {
        return a + b;
    }
}
public class calc2 extends calc {
    @override
    public int add(int a, int b) {
        return a + b + 1;
    }
}
```

Строка `@override` не является обязательной, но ее использование позволяет избежать ошибок при переопределении методов.

Стоит отметить, что переопределение методов не является полной заменой перегрузки методов. Перегрузка методов используется для создания различных вариантов одного и того же метода, а переопределение методов используется для изменения поведения метода в подклассе.

### 48. В чем разница между перегрузкой и переопределением методов, поясните

В Java перегрузка методов и переопределение методов — это две разные концепции, связанные со способностью иметь несколько методов с одним и тем же именем.

Перегрузка методов относится к способности класса иметь несколько методов с одним и тем же именем, но с разными списками параметров. Перегрузка метода — это способ предоставления нескольких реализаций метода в зависимости от количества и типа аргументов, переданных методу.

Переопределение метода относится к способности подкласса переопределять или переопределять метод, который он унаследовал от своего суперкласса. Переопределение метода позволяет подклассу предоставлять собственную реализацию метода, унаследованного от суперкласса, а также изменять или расширять поведение метода.

Вот основные различия между перегрузкой и переопределением методов в Java:

- Перегрузка основана на количестве и типе аргументов, переданных методу, а переопределение основано на сигнатуре метода. Сигнатура метода состоит из имени метода, количества и типа аргументов, а также порядка аргументов.
- Перегрузка происходит внутри одного класса, а переопределение происходит между суперклассом и подклассом. Перегрузка методов позволяет классу иметь несколько методов с одинаковыми именами, но с разными списками параметров в одном классе. Переопределение метода позволяет подклассу переопределить или переопределить метод, который он унаследовал от своего суперкласса.
- Перегрузка не связана с наследованием, а переопределение связано с наследованием. Перегрузка методов не требует наследования, так как происходит внутри одного класса. Переопределение метода включает в себя наследование, поскольку позволяет подклассу переопределять или переопределять метод, который он унаследовал от своего суперкласса.
- Перегрузка разрешается во время компиляции, а переопределение разрешается во время выполнения. Перегрузка метода разрешается во время компиляции на основе количества и типа аргументов, переданных методу. Компилятор Java определяет, какую перегруженную версию метода следует вызывать, на основе аргументов, переданных методу.

### 49. Абстрактные классы в Джава и абстрактные методы класса

В Java абстрактный класс — это класс, который не может быть создан и который используется для обеспечения общей базы для подклассов. Абстрактный класс определяется с помощью ключевого слова `abstract` и может содержать как абстрактные, так и конкретные методы.

Абстрактные методы — это методы, объявленные в абстрактном классе, но не имеющие реализации. Абстрактные методы используются для определения сигнатуры метода, но не реализации, и предназначены для реализации подклассами.

Абстрактные методы определяются с помощью ключевого слова `abstract` и не содержат тела метода. Абстрактные методы должны быть переопределены в подклассах, иначе подкласс должен быть объявлен абстрактным. Также абстрактные методы не могут быть объявлены как `final`, `static` или `private`.

Стоит отметить, что абстрактные классы могут содержать как абстрактные, так и конкретные методы. Конкретные методы — это методы, которые имеют реализацию. Конкретные методы могут быть объявлены как `final`, `static` или `private`, но не могут быть объявлены как `abstract`.

```Java
abstract class Shape {
    abstract void draw();
    void msg() {
        System.out.println("This is a shape");
    }
}
```

Чтобы использовать абстрактный класс, необходимо создать подкласс, который наследует абстрактный класс и реализует абстрактные методы. В приведенном ниже примере класс `Rectangle` наследует абстрактный класс `Shape` и реализует абстрактный метод `draw()`:

```Java
class Rectangle extends Shape {
    void draw() {
        System.out.println("drawing rectangle");
    }
}
```

Абстрактные методы могут быть переопределены в подклассах, но не могут быть переопределены в классах, которые не являются подклассами абстрактного класса.

### 50. Виды наследования в Джава, использование интерфейсов для реализации наследования

В Джава существует следующие виды наследования:

- Одиночное наследование: при одиночном наследовании подкласс расширяет один суперкласс и наследует все свойства и методы суперкласса. Синтаксис одиночного наследования в Java следующий:

```Java
class Subclass-name extends Superclass-name {
   //methods and fields
}
```

- Множественное наследование: при множественном наследовании подкласс расширяет несколько суперклассов и наследует свойства и методы всех суперклассов. Множественное наследование напрямую не поддерживается в Java, так как это может привести к неоднозначности и сложности.

- Интерфейсное наследование: при интерфейсном наследовании подкласс реализует один или несколько интерфейсов. Синтаксис интерфейсного наследования в Java следующий:

- иерархическое наследование: при иерархическом наследовании подкласс расширяет один суперкласс и наследует все свойства и методы суперкласса. Синтаксис иерархического наследования в Java следующий:

```Java
class Subclass-name extends Superclass-name {
   //methods and fields
}

class SubSubclass-name extends Subclass-name {
   //methods and fields
}
```

- Интерфейсное наследование: при интерфейсном наследовании подкласс реализует один или несколько интерфейсов. Синтаксис интерфейсного наследования в Java следующий:

```Java
class Subclass-name implements Interface-name, Interface-name, ... {
   //methods and fields
}
```

### 51. Что наследуется при реализации наследования в Джава (какие компоненты класса), а что нет?

При реализации наследования в Java подкласс наследует все поля и методы суперкласса, кроме приватных полей и методов. Подкласс также может расширять суперкласс, добавляя свои собственные поля и методы.

Подкласс не наследует закрытые поля и методы своего суперкласса, поскольку закрытые поля и методы недоступны за пределами класса, в котором они определены. Приватные поля и методы предназначены для использования только внутри класса, в котором они определены, и не предназначены для совместного использования с другими классами.

Подкласс также может определять свои собственные поля и методы, которые не наследуются от суперкласса. Эти поля будут недоступны в суперклассе.

Пример:

```Java
class A {
   int i; // this is public
   private int j; // this is private
   A(int i, int j) {
      this.i = i;
      this.j = j;
   }
}

class B extends A {
   int total;
   void sum() {
      this.total = i + j; // ERROR, j is not accessible here
   }
}
```

Как видно из примера, подкласс не может использовать закрытые поля и методы своего суперкласса. Подкласс может использовать только открытые поля и методы своего суперкласса.

Конструкторы не наследуются. Подкласс не наследует конструкторы своего суперкласса. Подкласс должен явно вызывать конструктор своего суперкласса, используя ключевое слово super, чтобы инициализировать суперкласс.

Пример:

```Java
class A {
   int i;
   A(int i) {
      this.i = i;
   }
}
Class B extends A {
   int j;
   B(int i, int j) {
      super(i);
      this.j = j;
   }
}
```

### 52. К каким методам и полям базового класса производный класс имеет доступ (даже если базовый класс находится в другом пакете), а каким нет? Область видимости полей и данных из производного класса

В Java существует 4 уровня доступа к полям и методам класса:

- public - доступно всем
- protected - доступно внутри пакета и в подклассах
- default - доступно внутри пакета
- private - доступно только внутри класса

## Тема 4. Полиморфизм в Джава. Работа со строками. Интерфейсы

### 53. Объявление и инициализация переменных типа String

В Java существует 2 способа инициализации переменных типа String:

- прямая инициализация

Синтаксис:

```Java
Имя_переменной = "Значение";
```

- инициализация с помощью конструктора

Синтаксис:

```Java
Имя_переменной = new String("Значение");
```

Литералы хранятся в пуле строк, а переменные типа String - в куче. Поэтому, при присваивании литерала типа String переменной типа String, создается новый объект типа String.

Рассмотрим пример:

```Java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
```

В данном примере, переменная s1 и литерал "hello" хранятся в пуле строк, а переменная s2 и литерал "hello" хранятся в куче. Поэтому, при сравнении переменных s1 и s2, результатом будет true, а при сравнении переменных s1 и s3, результатом будет false.

Для сравнения строк используется метод equals(), который возвращает true, если строки равны, и false, если строки не равны.

Синтаксис:

```Java
Имя_переменной_1.equals(Имя_переменной_2);
```

### 54. Операция конкатенации строк и ее использование

В Java вы можете использовать оператор «+» для конкатенации (объединения) двух или более строковых значений. Это называется операцией конкатенации строк.

Синтаксис:

```Java
Имя_переменной_1 + Имя_переменной_2;
```

Это создает новую строку с именем «результат», которая представляет собой конкатенацию строк «строка1» и «строка2».

Вы также можете использовать оператор «+» для объединения строковых значений с другими типами данных. Например, вы можете объединить строку с числом, результатом будет строка. Целое число будет преобразовано в строку, а затем объединено с другой строкой.

Пример:

```Java
String result = "строка1" + 2; // результатом будет строка "строка12"
```

Также можно использовать метод concat() для конкатенации строк. Этот метод возвращает новую строку, которая является результатом конкатенации двух строк. Данный метод не изменяет исходные строки. Он также определен в классе String.

Синтаксис:

```Java
Имя_переменной_1.concat(Имя_переменной_2);
```

Важно отметить, что операция конкатенации строк неэффективна, так как она создает новый строковый объект для каждой конкатенации. Если вам нужно объединить много строк, вместо этого рекомендуется использовать класс `StringBuffer` или `StringBuilder`.

### 55. Что означает утверждение, что объект класса String является неизменяемым

В Java объект класса "String" является неизменяемым, что означает, что его нельзя изменить после создания.

Неизменяемый объект — это объект, состояние которого нельзя изменить после его создания. Это означает, что после создания строкового объекта вы не можете изменить его значение или содержимое.

Например, рассмотрим следующий код:

```Java
String str = "строка";
str.toUpperCase();
```

В этом коде строка `str` инициализируется значением «Hello». Затем для строки `str` вызывается метод `toUpperCase()`, который преобразует строку в верхний регистр. Однако этот метод не изменяет строку `str`, поскольку она неизменяема.

Вместо этого метод `toUpperCase()` создает новый строковый объект со значением в верхнем регистре и возвращает его. Если вы хотите сохранить результат метода `toUpperCase()`, вам нужно присвоить его новой строковой переменной:

```Java
String str = "строка";
String strUpper = str.toUpperCase();
```

Этот код создает новую строку с именем `strUpper`, которая является результатом применения метода `toUpperCase()` к строке `str`. Строка `str` остается неизменной.

Неизменяемый объект полезен во многих случаях, так как он гарантирует, что состояние объекта не может быть изменено по ошибке или другой частью кода. Это может помочь избежать ошибок и несоответствий в вашем коде.

Однако важно отметить, что неизменяемый объект — не всегда лучший выбор, поскольку в некоторых случаях он может быть неэффективным. Например, если вам нужно выполнить множество операций над строкой, например конкатенацию, более эффективно использовать изменяемый объект, такой как `StringBuilder` или `StringBuffer`, который можно изменить без создания нового объекта для каждой операции.

### 56. При создании объектов строк с помощью класса StringBuffer, например StringBuffer strBuffer = new StringBuffer(str) можно ли использовать операцию конкатенации строк или необходимо использовать методы класса StringBuffer

В Java при создании строкового объекта с помощью класса `StringBuffer` вы можете использовать операцию конкатенации строк, а также методы класса `StringBuffer` для изменения строки.

Класс `StringBuffer` — это изменяемая (модифицируемая) версия класса `String`, которая позволяет изменять строку без создания нового объекта для каждой операции.

Чтобы создать строковый объект с помощью класса StringBuffer, используйте следующий синтаксис:

```Java
StringBuffer имя_объекта = new StringBuffer(строка);
```

Чтобы объединить две строки с помощью класса `StringBuffer`, используйте метод `append()`.

```Java
StringBuffer strBuffer = new StringBuffer("Hello");
strBuffer.append(" World");
System.out.println(strBuffer); // Hello World
```

### 57. Объявление и инициализация массива строк. Организация просмотра элементов массива

Для объявления массива строк используется следующий синтаксис:

```Java
String[] имя_массива = new String[количество_элементов];
```

Также можно объявить массив строк и сразу инициализировать его значениями:

```Java
String[] имя_массива = {"значение1", "значение2", "значение3"};
```

Для просмотра элементов массива используется цикл `for-each` (либо цикл `for`):

```Java
for (String str : имя_массива) {
    System.out.println(str);
}
```

Также можно использовать класс `Arrays` для просмотра элементов массива:

```Java
System.out.println(Arrays.toString(имя_массива));
```

В данном случае метод `toString()` возвращает строку, которая содержит все элементы массива, разделенные запятой.

### 58. Понятие и объявление интерфейсов в Джава

В Джава интерфейс — это абстрактный тип данных, который содержит только объявления методов, но не содержит реализацию этих методов. Интерфейсы используются для описания поведения класса, но не для реализации этого поведения.

Для объявления интерфейса используется следующий синтаксис:

```Java
interface Имя_интерфейса {
    // объявление методов
}
```

Для реализации интерфейса в классе используется следующий синтаксис:

```Java
class Имя_класса implements Имя_интерфейса {
    // реализация методов
}
```

Интерфейсы могут содержать константы, но не могут содержать переменные.

Рассмотрим пример объявления интерфейса и класса, который реализует этот интерфейс:

```Java
interface Shape {
    double PI = 3.14;
    void draw();
}

class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Рисуем круг");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape shape = new Circle();
        shape.draw();
    }
}
```

В данном примере интерфейс `Shape` содержит константу `PI` и метод `draw()`. Класс `Circle` реализует интерфейс `Shape` и реализует метод `draw()`. Также при создании объекта класса `Circle` мы можем использовать ссылку на интерфейс `Shape`, так как класс `Circle` реализует интерфейс `Shape`.

Интерфейс полезен во многих случаях, так как он позволяет определить набор поведений или функций, которые должен реализовать класс, не указывая, как эти поведения реализуются. Это позволяет вам создавать гибкий и многоразовый дизайн для вашего кода и применять один и тот же интерфейс к разным классам с разными реализациями.

В новых версиях Java (с 8 по 11) интерфейсы могут содержать статические методы, которые реализуются в классе, который реализует интерфейс. Для объявления статического метода в интерфейсе используется следующий синтаксис:

```Java
interface Имя_интерфейса {
    static void имя_метода() {
        // тело метода
    }
}
```

### 60. Что входит в состав интерфейса. (какие компоненты может содержать интерфейс)?

Интерфейс может содержать следующие компоненты:

- Константы. Поля, объявленные в интерфейсе, должны быть инициализированы и являются константами. Эти константы не могут быть изменены в классе, который реализует интерфейс.

- Абстрактные методы (методы без реализации). Методы, объявленные в интерфейсе, должны быть абстрактными. Эти методы должны быть реализованы в классе, который реализует интерфейс.

- Методы по умолчанию (default methods). Методы, объявленные в интерфейсе, могут быть реализованы в интерфейсе. Эти методы могут быть переопределены в классе, который реализует интерфейс.

- Статические методы (static methods). Методы, объявленные в интерфейсе, могут быть реализованы в интерфейсе. Эти методы не могут быть переопределены в классе, который реализует интерфейс.

- Вложенные типы (nested types). Интерфейс может содержать вложенные типы, такие как классы, интерфейсы, перечисления и аннотации.

### 61. Может ли интерфейс наследоваться от другого интерфейса?

Да, интерфейс может наследоваться от другого интерфейса. Интерфейс может наследовать только интерфейсы, но не классы.

### 62. Интерфейс Camparable, назначение, его методы и использование в Джава

В Java интерфейс `Comparable` — это стандартный интерфейс, который определяет метод, называемый `compareTo()`, который позволяет сравнивать два объекта. Интерфейс `Comparable` является частью пакета `«java.lang»` и реализуется многими классами в библиотеке Java, такими как `String`, `Integer` или `Double`.

Интерфейс Comparable имеет следующий синтаксис:

```Java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

Этот интерфейс объявляет один абстрактный метод с именем `compareTo()`, который принимает один аргумент типа `T` и возвращает значение `int`. Параметр типа `T` представляет тип сравниваемых объектов.

Чтобы реализовать `Comparable` интерфейс в классе, необходимо реализовать метод `compareTo()`.

Если метод `compareTo()` возвращает положительное число, то первый объект больше второго объекта. Если метод `compareTo()` возвращает отрицательное число, то первый объект меньше второго объекта. Если метод `compareTo()` возвращает ноль, то объекты равны.

Пример:

```Java
public class Student implements Comparable<Student> {
    private String name;
    private int age;
    private int rollNo;
    private String className;
    // getters and setters
    @Override
    public int compareTo(Student student) {
        return (this.rollNo - student.rollNo);
    }
}
```

### 63. Какое значение возвращает вызов метода object1.compareTo(object2), который сравнивает 2 объекта obj1 и obj2 в зависимости от объектов?

Если объект obj1 больше объекта obj2, то метод `compareTo()` возвращает положительное число. Если объект obj1 меньше объекта obj2, то метод `compareTo()` возвращает отрицательное число. Если объект obj1 равен объекту obj2, то метод `compareTo()` возвращает ноль.

### 64. Интерфейсные ссылки и их использование в Джава

В Java ссылка на интерфейс — это ссылочная переменная, которая может содержать ссылку на объект класса, реализующего конкретный интерфейс. Ссылка на интерфейс позволяет получить доступ к методам интерфейса через объект, не зная деталей реализации класса.

Чтобы объявить ссылку на интерфейс в Java, вы можете использовать имя интерфейса в качестве типа ссылочной переменной, за которым следует имя переменной.

Например, рассмотрим следующее объявление ссылки на интерфейс:

```Java
Shape shape;
```

Объявляется ссылочная переменная с именем «shape», которая может содержать ссылку на объект класса, реализующего интерфейс «Shape».

Чтобы создать объект класса, реализующего интерфейс, вы можете использовать оператор `new`, за которым следует имя класса и аргументы конструктора.

Например, рассмотрим следующий код:

```Java
Shape shape = new Circle();
```

Этот код создает новый объект класса `Circle`, который реализует интерфейс `Shape`, и присваивает его ссылке интерфейса `Shape`.

Ссылка на интерфейс полезна во многих случаях, поскольку позволяет получить доступ к методам интерфейса, не зная деталей реализации класса. Это позволяет вам создавать гибкий и многоразовый дизайн для вашего кода и применять один и тот же интерфейс к разным классам с разными реализациями.

## Тема 5. Основные принципы и типы исключительных ситуаций

### 65. Понятие исключительной ситуации и ее обработка

### 66. В каком случае программа должна использовать оператор throw?

### 67. В Java все исключения делятся на два основных типа. Что это за типы и какие виды ошибок ни обрабатывают?

### 68. Код ниже вызовет ошибку: Exception <...> java. lang.ArrayIndexOutOfBoundsException: 4: Что она означает?

### 69. Контролируемые исключения (checked)

### 70. Неконтролируемые исключения (unchecked) и ошибки, которые они обрабатывают

### 71. Как реализуется принципы ООП в Java при создании исключений?

### 72. Какой оператор позволяет принудительно выбросить исключение?

### 73. Порядок выполнения операторов при обработке блока блока try...catch

## Тема 6. Дженерики и использование контейнерных классов в Джава

### 74. Абстрактный тип данных Stack (cтек) в Java

### 75. Универсальные типы или обобщенные типы данных, для чего создаются?

### 76. Объявление обобщённого класса коллекции с параметризованным методом для обработки массива элементов коллекции на основе цикла foreach (определение общего метода для отображения элементов массива)

### 77. Что представляет из себя класс ArrayList и в каком случае используется

### 78. Класс Pattern и его использование

### 79. Класс Math и его использование

### 80. Как вызываются методы класса Math и что при этом происходит?

## Тема 7. Java Core. Дженерики (продолжение) и использование контейнерных классов Java Framework Collection

### 81. Структура коллекций в Java Collection Framework. Иерархия интефейсов

### 82. Коллекция HashMap, создание и методы работы с ней

### 83. Чем является класс LinkedList<E>

### 84. Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Что возвращает это метод?

### 85. Что возвращает метод next()

### 86. Что возвращает метод hasNext()

### 87. Обобщенный класс HashSet класс коллекция, наследует свой функционал от класса AbstractSet, а также реализует интерфейс Set. Что он себя представляет?

### 88. Обобщенный класс HashMap класс коллекция, которая реализует интерфейс Map для хранения пар ключ-значение. Что он себя представляет?

## Тема 8. Стандартные потоки ввода-вывода. Сериализация

### 89. Стандартные поток ввода-вывода, предоставляемые Java

### 90. Понятие сериализации, интерфейс Serializable

### 91. Какие объекты можно сериализовать?

### 92. Какие методы определяет интерфейс Serializable?

### 93. Что означает понятие десериализация?

### 94. Класс File, определенный в пакете java.io, не работает напрямую с потоками. В чем состоит его задача?

### 95. При работе с объектом класса FileOutputStream происходит вызов метода FileOutputStream.write(), что в результате этого происходит
